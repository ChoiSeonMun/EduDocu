### 7. 배열과 문자열
#### - 학습 목표
> **1.** 배열 자료구조를 이해하고 사용할 수 있다.
> **2.** 배열과 포인터의 관계를 이해한다.
> **3.** 문자열에 익숙해진다.
---
#### - 배열

어떤 강의의 수강 학생들의 점수를 분반별로 컴퓨터에 입력하려고 한다. 각 분반엔 50명씩 분포되어 있으며, 이름 순으로 정렬되어 있다고 가정한다. 그렇다면 아마 이런식으로 변수들을 정의할 수 있을 것이다.

```c++
int grade01;
int grade02;
int grade03;
...
int grade49;
int grade50;
```

한 분반에서만 이정도고, 분반이 여러개가 있다면 정의만 수십줄이 될 것이다. 물론 관리하기 어려운 것은 덤이다. 그러나, 배열을 이용한다면 다음과 같이 한번에 정의할 수 있다.

```c++
int grade[50];
```

아까보다 가독성도 높고 직관적이다. 또한 관리하기도 왠지 쉬워보인다. 이번 시간에는 배열에 대해서 알아본다.

- 선언 및 정의

**배열**(array)이란 같은 자료형들의 묶음이다. 메모리 상으로도 일렬로 쭉 배치되어 있다. 데이터 하나를 **요소**(element)라 하며, **인덱스**(index)를 이용해 각 원소에 접근할 수 있다. 배열 정의는 다음과 같다.

> <center> 타입 식별자[상수] </center>

<center>
<img src="http://www.studytonight.com/c/images/array-declaraction-in-c.jpg" title="배열의 배치">
</center>

배열은 컴파일 때 크기를 알고 있어야 한다. `[]`연산자 사이에 '상수'가 들어간다는 것에 유의하자. 상수는 보통 기호상수를 이용한다. 그 편이 코드를 이해하는 데에도 편하고, 후에 배열 크기를 수정할 때에도 편하기 때문이다. 또한, 배열의 인덱스는 0부터 시작한다. 예를 들면, 위의 `grade` 배열에 접근할 수 있는 인덱스는 0~49까지이다.

```c++
int grade[0];   // ok
int grade[1];   // ok
int grade[50];  // no, out of range
```

- 초기화

배열의 초기화는 `{}`연산자를 이용한다.

```c++
int grade1[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int grade2[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
// 초기화를 한다면 상수 생략 가능
// 컴파일러가 초기화의 갯수에 맞춰 자동으로 배열 크기를 정한다
// 이 경우 10
```

0으로 초기화를 하고 싶다면 다음과 같이 두 가지가 있다.

```c++
int grade1[10] = { 0 };
int grade2[10] = { 0, };
```

보통 두 번째를 많이 봤을 텐데, 첫 번째도 가능하다. 둘 다 눈에 익혀 놓도록 하자. 그럼 다음과 같은 경우는 어떻게 될까?

```c++
int grade1[10] = { 0, 1, 2 };
```

직접 확인해보기 바란다.

- 크기 구하기

배열의 크기는 `sizeof` 연산자를 이용하면 자료형 x 갯수 만큼의 크기가 나온다.

```c++
int grade[10];
printf("%d", sizeof(grade)); // 4 byte * 10 = 40
```

이 사실을 이용하면 역으로 배열의 요소의 갯수도 구할 수 있을 것이다.

- 다차원 배열

아까와 같은 배열을 1차원 배열이라 한다. 1차원 말고도 2차원, 3차원, 4차원 등 다차원 배열을 정의할 수 있다.

> <center> 타입 식별자[n차원 크기][n - 1차원 크기]...[2차원 크기][1차원 크기]; </center>

초기화는 다음과 같다.

```c++
int a[3][4] = {
    {0, 1, 2, 3},
    {4, 5, 6, 7},
    {8, 9, 10, 11}
};                  //; 주의!
```

<center>
<img src="http://www.studytonight.com/c/images/two-dimensional-array.jpg">
</center>
<p>
<center>
<b>int a[3][4]</b>
</center>
</p>

`int a[3][4]`에 있을 때, 이런 모양으로 상상해볼 수 있을 것이다. 그렇다면 메모리 상에서는 어떻게 될까? 메모리 상에서도 이런 면 모양으로 저장이 될까? 아니다. 메모리 상에서는 일렬로 쭉 배치되어 있다. 다음의 예제를 디버그 모드에서 확인해보라.

```c++
//다차원 배열 예제 - 1
int main()
{
  int a[3][4] = { 0 }; // 0으로 초기화
                       // {0, 0, 0, 0}
                       // {0, 0, 0, 0}
                       // {0, 0, 0, 0}
  int* aptr = &a[0][3]; // 첫 행의 마지막에 위치해 있다.
                        // {0, 0, 0, 0}
                        //           ↑ aptr
                        // {0, 0, 0, 0}
                        // {0, 0, 0, 0}
  ++aptr;               // 이동
                        // {0, 0, 0, 0}
                        // {0, 0, 0, 0}
                        //  ↑ aptr
                        // {0, 0, 0, 0}

  return 0;
}
```

즉, 다음과 같다.

![1](http://i.imgur.com/RgWVFCA.png)

이렇다고 `a[11] == a[2][2]` 인 것은 아니다. 이런 식으로 쓰면 행 단위로 점프한다는 사실을 유념해두자.

#### - 배열과 포인터

- 배열의 퇴화

c/c++에서 배열과 포인터는 긴밀한 관계가 있다. 배열 변수는 배열의 첫 주소를 담고 있기 때문이다. 그래서, `grade[2]`는 `*(grade + 2)`와도 동일하다. 포인터에 배열을 담는 것도 가능하다.

```c++
int arr[10] = { 0 };
int* aptr = arr; // &연산자가 없는 것에 주의
printf("%d", aptr[2]); // 배열을 담고 있는 경우
                       // 포인터도 인덱싱으로 접근할 수 있다.
printf("%d", sizeof(arr)); // 40
printf("%d", sizeof(aptr)); // 4
```

당연히 둘의 기본 자료형은 같아야 하고, 단일 포인터에는 1차원 배열만 담을 수 있다. `sizeof`의 결과값이 다른 것에 유의하라. 배열은 배열 크기 전체가 반환되지만, 포인터는 포인터의 크기가 반환된다. 이렇게 포인터에 배열을 담을 수 있는 것을 배열이 **퇴화**(decay)되었다고 한다.

- 매개변수로서의 배열

이 같은 사실을 이용하면 함수에서 매개변수에 배열로 쓰나, 포인터로 쓰나 동일하다는 사실을 알 수 있다.

```c++
void PrintArray(int arr[], int size);
void PrintArray(int* arr, int size);
```

두 함수는 시그너처는 완전히 같다. 그저 편의상 `int[]` 형식으로 기술하는 것뿐이다.

또, 여기서 주목해볼 것은 함수에서 배열을 다루고 싶다면 그 함수의 크기를 같이 넘겨줘야 한다는 것이다. 왜 그런지는 각자가 한번 생각해보도록 하자.

- 동적 배열

아까의 강의 점수 예시를 확장을 해보겠다. 이번엔 분반 별로 학생 수가 모두 다르다고 할 때, 이 학생들의 데이터를 입력받으려면 어떡할 것인가? 각 분반당 최대 학생 수를 100명이라고 하자. 보통 그럼 최대 학생수에 맞춘 배열을 생성할 것이다.

```c++
int grade[100];
```

만약, 들어오는 입력의 갯수가 10개라면? 그럼 나머지 90개의 요소만큼의 메모리가 낭비되는 것이다. 이처럼 정적 배열의 단점은 유연성이 떨어진다는 것이다. 지금 볼 것은 메모리 할당을 통한 **동적 배열**(dynamic array)을 보고자 한다. 다음 예제를 보자.

```c++
//메모리 할당 예제 - 1
#include <stdio.h>
#include <stdlib.h> // for malloc, free

int main(void)
{
  int num = 0;
  int* arr = nullptr;
  while (true)
  {
    printf("해당 분반의 학생 수는 몇 명입니까? : ");
    scanf("%d", &num);
    arr = (int*)malloc(sizeof(int) * num); // 메모리 할당
    puts("학생들의 점수를 입력해주세요.");
    for (int i = 0; i < num; ++i)
    {
      scanf("%d", &arr[i]);
    }
    free(arr); // 메모리 해제(반환)
    arr = nullptr; // 습관들이는 것이 좋다.
  }
}
```

어떻게 사용하는지 좀 알겠는가? `malloc()`을 이용해서 메모리 할당을 받는데 `sizeof(요소의 타입) * 요소의 갯수`만큼 메모리를 할당 받는다. 사용 후에는 반드시 `free()`를 이용해 해제하자. 그렇지 않으면 **메모리 누수**(leak)가 일어난다. 할당 후에는 정적 배열 사용하듯 사용하면 된다.  

#### - 문자열

지금까지는 문자 하나만 다뤄보았다. 이제부터는 문자들의 집합인 문자열을 다뤄보고자 한다. 문자열은 `char`형의 배열에 지나지 않다. 문자열을 다루는 두 가지 방법을 보고자 한다.

- 포인터

포인터를 이용하면 문자열 리터럴을 가리킬 수 있다. 다음을 보자.

```c++
// 문자열 예제 - 1
#include <stdio.h>

int main()
{
  char* str = "Hello, World";
  printf("%s", str); // 문자열 출력에는 %s이다.
  return 0;
}
```

여기서 `str`은 그저 어딘가에 저장되어 있는 `"Hello, World"`란 문자열 리터럴을 가리키고 있을 뿐이다. `str[1] = 'W'`와 같은 쓰기는 할 수 없고 오직 읽기만 가능하다.

<center>
<img src="http://i.imgur.com/d9zsNVL.png" title="포인터로 가르킨 문자열">
</center>

뒤에 이상한 문자가 보인다. 바로 **널 문자**(null character)인데, 이게 있어야 문자열이 언제 끝나는지 컴퓨터가 알 수 있다.

- 배열

이번에는 배열로 문자열을 다루는 것을 살펴보자.

```c++
//문자열 예제 - 2
#include <stdio.h>

int main()
{
  char str[] = "Hello, World"; // 중괄호를 안씌워도 됨!
  return 0;
}
```

문자열의 초기화에는 중괄호를 안씌워도 괜찮다. 그럼 여기서 `str`의 크기는 몇일까? 정답은 13이다. 문자 배열에 크기를 명시하는 경우에는 꼭 널 문자를 위한 공간을 뺴먹지 않도록 주의하자.

```c++
char str[12] = "Hello, World!"; // warning!
```

배열을 이용하는 경우에는 읽기 말고도 쓰기도 가능하다.

- 문자열 함수

문자열과 관련된 함수에는 `<string.h>`에 들어있다. 여기엔 여러가지 함수가 있지만, 그 중 많이 사용되는 함수 몇개만 소개하려 한다.

> - strcmp : 문자열을 비교하는 함수이다.
`int strcmp(const char* str1, const char* str2)`
> - strcpy : 문자열을 복사하는 함수이다.
`char * strcpy(char * destination, const char * source)`
> - strcat : 문자열을 붙이는 함수이다.
`char * strcpy(char * destination, const char * source)`
> - strlen : 문자열의 크기를 구하는 함수이다.
`size_t strlen(const char * str)`
> - strtok : 문자열을 토큰으로 나눈다.
`char * strtok(char * str, const char * delimiters)`
<!--- 구두로 설명 --->

----
## 과제

**1.** `int grade1[10] = { 0, 1, 2 };` 에서 `grade1`의 각 요소 값들을 적어보아라.

**2.** `sizeof`를 이용해 `int grade1[10]`의 크기를 구해보아라.

**3.** 왜 배열을 인자로 넘겨줄 때, 크기도 같이 넘겨야 하는가?

**4.** HQ9+ 라는 프로그래밍 언어는 세상에서 가장 간단한 언어이다.

명령어는 아래와 같다.

H: 그 유명한 'Hello, world!'라는 문구를 출력시킨다.
Q: 프로그램 소스를 출력시킨다.
9: "99 Bottles of Beer on the Wall" 라는 노래의 가사를 출력한다. 하지만 이 문제에서는 "99 Bottles of Beer on the Wall" 만 출력한다.
+: 누산기를 증가시킨다. 이 문제에서는 나오지 않는다.
여러분이 해야 할 일은 소스 코드를 입력받아 결과를 출력하는 일이다.

**입력**
> h,q,k 문자가 한 줄에 입력으로 주어진다. 대소문자는 구별하지 않는다.
문자열의 크기는 25 이하이다.

**출력**
> 출력 예의 형식으로 출력한다.

**예시**
- 입력
```
qQqQqQqQ
```
- 출력
```
qQqQqQqQ
qQqQqQqQ
qQqQqQqQ
qQqQqQqQ
qQqQqQqQ
qQqQqQqQ
qQqQqQqQ
qQqQqQqQ
```
- 입력
```
9hhq
```
- 출력
```
99 Bottles of Beer on the Wall
Hello, world!
Hello, world!
9hhq
```

**5.** 문자열에 있는 `FOO`를 모두 `OOF`로 바꾸는 프로그램을 작성하라. 입력은 총 5개의 대문자 문자열로 주어진다. 각 문자열은 최대 25 크기를 갖는다.

**예시**
- 입력
```
FOOK
FOOOOOPLE
FOKE
OFOOL
FOOOO
```
- 출력
```
OOFK
OOOOFOPLE
FOKE
OOOFL
OOOOF
```

**6.** `"Alice's Adventures in Wonderland"`를 각 단어별로 자르는 프로그램을 작성한다.
**예시**
- 출력
```
Alice's
Adventures
in
Wonderland
```

----
## 이미지 출처
1. 배열 이미지 : http://www.studytonight.com/c/arrays-in-c.php
